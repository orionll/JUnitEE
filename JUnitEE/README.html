<html>
	<head>
		<title> JUnitEE </title>
	</head>

	<body>
		<p>
			Hi.
		</p>

		<p>
			This tool provides a TestRunner and a servlet which will run
			JUnit test suites in an app server.  The jar file contains these
			classes in a package called <tt>junit.htmlui</tt> which I hope will
			eventually be included in the standard JUnit distribution.
		</p>

		<p>
			You should probably read the <a href="doc/tutorial.html">tutorial</a>.
		</p>

		<p>
			First a quick note about unit testing an EJB application:  I highly
			recommend that you do NOT run tests on a production server.  I have
			put all of my unit test code in a special test web application and
			only install it on the test servers (hooked up to test databases).
  			This should be pretty obvious, but it's probably worth emphasizing.
		</p>

		<p>
			A second quick note about these tools:  The servlet isn't the most
			intelligent thing in the world, and at the moment it tries to run
			the entire test suite in a single HTTP request, giving you no
			indication of its progress.  Sometime (probably around the
			time that my tests start taking long enough to be annoying :-) I will
			rewrite the servlet to use the HTTP Refresh header to display
			progress.
		</p>

		<p>
			To use this tool you perform the following steps (assuming you have
			a J2EE-compliant app server):
			<ol>
				<li>
 					Put <tt>junitee.jar</tt> somewhere that your app server will find.
					Usually this is a <tt>lib</tt> directory in the app server directory,
					but you can also use the system classpath or even drop the
					jar directly into your web application's <tt>WEB-INF/lib</tt> directory.
				</li>
				<li>
					Do the same for the normal <tt>junit.jar</tt> file.
				</li>
				<li>
					Create a servlet class in your web application's
					<tt>WEB-INF/classes</tt> directory which extends the abstract
					class <tt>junit.htmlui.TestServletBase</tt>.  See the example
					<tt>TestServlet</tt> included with this archive.
				</li>
				<li>
					Add the servlet to your web.xml file at an appropriate path.
				</li>
				<li>
					Create a web page as part of your web-application that
					provides an interface to the servlet.  See the example
					<tt>TestForm.html</tt> included with this archive.  You
					will need to adjust the path to match what you specified
					in web.xml.
				</li>
			</ol>
		</p>

		<p>
			I know what you're thinking.  You're wondering why the servlet
			is abstract and why you can't just reference the
 			<tt>junit.htmlui.TestServletBase</tt> directly from the web.xml.
			I was wondering that myself as I kept getting ClassNotFoundExceptions.
			Here is the story:
		</p>

		<p>
			The problem is that in order for this to work, the TestRunner
			needs to load classes using the special classloader that the
			app server uses.  Neither the web application classes
			nor the ejb classes are part of the standard classpath; they
			are loaded by the app server's special classloader which not
			only knows all the cool places to look for classes but also
			will dynamically reload classes which have changed.  Extra-spiffy
			loaders will even recompile java files which are in the same dir.
		</p>

		<p>
			Unfortunately the classloader that the app server uses to load
			jar files in the app server's <tt>lib</tt> directory is not
			nearly so cool.  It doesn't know about the web application
			directory, much less have the ability to reload changed files.
			And it seems that the java system by default loads classes using
			the classloader that the creating class was loaded with.  So if
			I try to load classes from within the junit.htmlui classes, I
			don't have access to the web application classes.  I need to
			get an explicit reference to the "smart" classloader, and the
			way to do that is to obtain it from a servlet in the actual
			web application directory.  Thus in order to use
			<tt>junit.htmlui.TestServlet</tt>, you must derive from it
			a servlet and implement the abstract <tt>getDynamicClassLoader()</tt>
			method.  Blah.
		</p>

		<p>
			Formal disclaimer: if this tool explodes, destroying your
			machine room and everything around it in a 150-foot radius, including
			that pyramid of empty Dr. Pepper cans around your monitor, well,
			don't sue me.  I didn't <i>promise</i> that it would work.  In fact,
			since I've only ever run it against my own system, I'd guess that
			it's pretty likely that it won't.  But you have source code, so you
			can fix it yourself (after you clear all the soda cans off your keyboard
			and chair). Just send me a copy of the changes and it will save someone
			else the trouble.
		</p>

		<p>
			And clean up your bloody desk already.
		</p>

		<p>
			<cite>Jeff Schnitzer</cite> <br/>
			<a href="mailto:jeff@infohazard.org">jeff@infohazard.org</a>
		</p>
	</body>
</html>